/*
This file is part of rclgo

Copyright © 2021 Technology Innovation Institute, United Arab Emirates

Licensed under the Apache License, Version 2.0 (the "License");
    http://www.apache.org/licenses/LICENSE-2.0
*/

package gogen

import (
	"strings"
	"text/template"
)

var templateFuncMap template.FuncMap = template.FuncMap{
	"lc":                    strings.ToLower,
	"camelToSnake":          camelToSnake,
	"defaultCode":           defaultCode,
	"ucFirst":               ucFirst,
	"srvNameFromSrvMsgName": srvNameFromSrvMsgName,
	"cReturnCodeNameToGo":   cReturnCodeNameToGo,
	"cloneCode":             cloneCode,
}

var ros2MsgToGolangTypeTemplate = template.Must(template.New("ros2MsgToGolangTypeTemplate").Funcs(templateFuncMap).Parse(
	`/*{{ $Md := .Message }}
This file is part of rclgo

Copyright © 2021 Technology Innovation Institute, United Arab Emirates

Licensed under the Apache License, Version 2.0 (the "License");
	http://www.apache.org/licenses/LICENSE-2.0
*/

/*
THIS FILE IS AUTOGENERATED BY 'rclgo-gen generate'
*/

package {{ $Md.GoPackage }}
import (
	"unsafe"

	"{{.Config.RclgoImportPath}}/pkg/rclgo/types"
	"{{.Config.RclgoImportPath}}/pkg/rclgo/typemap"
	{{range $path, $name := $Md.GoImports -}}
	{{$name}} "{{$path}}"
	{{""}}{{- end}}
)
/*
#cgo LDFLAGS: -L/opt/ros/galactic/lib -Wl,-rpath=/opt/ros/galactic/lib -lrcl -lrosidl_runtime_c -lrosidl_typesupport_c -lrcutils -lrmw_implementation
#cgo LDFLAGS: -l{{$Md.Package}}__rosidl_typesupport_c -l{{$Md.Package}}__rosidl_generator_c
{{range $k, $v := $Md.CImports -}}
#cgo LDFLAGS: -l{{$k}}__rosidl_typesupport_c -l{{$k}}__rosidl_generator_c
{{""}}
{{- end}}
#cgo CFLAGS: -I/opt/ros/galactic/include

#include <rosidl_runtime_c/message_type_support_struct.h>
{{if eq $Md.Type "msg"}}
#include <{{$Md.Package}}/msg/{{$Md.Name | camelToSnake}}.h>
{{else if eq $Md.Type "srv"}}
#include <{{$Md.Package}}/srv/{{$Md.Name | srvNameFromSrvMsgName | camelToSnake}}.h>
{{end}}
*/
import "C"

func init() {
	typemap.RegisterMessage("{{$Md.Package}}/{{$Md.Name}}", {{$Md.Name}}TypeSupport)
}

{{- if $Md.Constants }}
const (
{{- range $Md.Constants }}
	{{$Md.Name}}_{{.RosName}} {{.GoPkgReference}}{{.GoType}} = {{.Value}}{{if .Comment -}} // {{.Comment}}{{- end}}
{{- end }}
)
{{- end }}

// Do not create instances of this type directly. Always use New{{$Md.Name}}
// function instead.
type {{$Md.Name}} struct {
	{{- range $k, $v := $Md.Fields }}
	{{$v.GoName }} {{$v.TypeArray}}{{$v.GoPkgReference}}{{$v.GoType}}` +
		"{{\"\"}} `yaml:\"{{$v.RosName}}\"`" + `{{if .Comment -}} // {{.Comment}}{{- end}}
	{{- end }}
}

// New{{$Md.Name}} creates a new {{$Md.Name}} with default values.
func New{{$Md.Name}}() *{{$Md.Name}} {
	self := {{$Md.Name}}{}
	self.SetDefaults()
	return &self
}

func (t *{{$Md.Name}}) Clone() *{{$Md.Name}} {
	c := &{{$Md.Name}}{}
	{{- range $f := $Md.Fields }}
	{{cloneCode $f}}
	{{- end }}
	return c
}

func (t *{{$Md.Name}}) CloneMsg() types.Message {
	return t.Clone()
}

func (t *{{$Md.Name}}) SetDefaults() {
	{{- range $k, $v := $Md.Fields }}
	{{defaultCode $v}}
	{{- end }}
}

// Clone{{$Md.Name}}Slice clones src to dst by calling Clone for each element in
// src. Panics if len(dst) < len(src).
func Clone{{$Md.Name}}Slice(dst, src []{{$Md.Name}}) {
	for i := range src {
		dst[i] = *src[i].Clone()
	}
}

// Modifying this variable is undefined behavior.
var {{$Md.Name}}TypeSupport types.MessageTypeSupport = _{{$Md.Name}}TypeSupport{}

type _{{$Md.Name}}TypeSupport struct{}

func (t _{{$Md.Name}}TypeSupport) New() types.Message {
	return New{{$Md.Name}}()
}

func (t _{{$Md.Name}}TypeSupport) PrepareMemory() unsafe.Pointer { //returns *C.{{$Md.Package}}__{{$Md.Type}}__{{$Md.Name}}
	return (unsafe.Pointer)(C.{{$Md.Package}}__{{$Md.Type}}__{{$Md.Name}}__create())
}

func (t _{{$Md.Name}}TypeSupport) ReleaseMemory(pointer_to_free unsafe.Pointer) {
	C.{{$Md.Package}}__{{$Md.Type}}__{{$Md.Name}}__destroy((*C.{{$Md.Package}}__{{$Md.Type}}__{{$Md.Name}})(pointer_to_free))
}

func (t _{{$Md.Name}}TypeSupport) AsCStruct(dst unsafe.Pointer, msg types.Message) {
	{{ if $Md.Fields -}}
	m := msg.(*{{$Md.Name}})
	mem := (*C.{{$Md.Package}}__{{$Md.Type}}__{{$Md.Name}})(dst)
	{{- range $Md.Fields }}
	{{call $.cSerializationCode . $Md}}
	{{- end }}
	{{- end }}
}

func (t _{{$Md.Name}}TypeSupport) AsGoStruct(msg types.Message, ros2_message_buffer unsafe.Pointer) {
	{{if $Md.Fields -}}
	m := msg.(*{{$Md.Name}})
	mem := (*C.{{$Md.Package}}__{{$Md.Type}}__{{$Md.Name}})(ros2_message_buffer)
	{{- range $Md.Fields }}
	{{call $.goSerializationCode . $Md}}
	{{- end }}
	{{- end }}
}

func (t _{{$Md.Name}}TypeSupport) TypeSupport() unsafe.Pointer {
	return unsafe.Pointer(C.rosidl_typesupport_c__get_message_type_support_handle__{{$Md.Package}}__{{$Md.Type}}__{{$Md.Name}}())
}

type C{{$Md.Name}} = C.{{$Md.Package}}__{{$Md.Type}}__{{$Md.Name}}
type C{{$Md.Name}}__Sequence = C.{{$Md.Package}}__{{$Md.Type}}__{{$Md.Name}}__Sequence

func {{$Md.Name}}__Sequence_to_Go(goSlice *[]{{$Md.Name}}, cSlice C{{$Md.Name}}__Sequence) {
	if cSlice.size == 0 {
		return
	}
	*goSlice = make([]{{$Md.Name}}, int64(cSlice.size))
	for i := 0; i < int(cSlice.size); i++ {
		cIdx := (*C.{{$Md.Package}}__{{$Md.Type}}__{{$Md.Name}}__Sequence)(unsafe.Pointer(
			uintptr(unsafe.Pointer(cSlice.data)) + (C.sizeof_struct_{{$Md.Package}}__{{$Md.Type}}__{{$Md.Name}} * uintptr(i)),
		))
		{{$Md.Name}}TypeSupport.AsGoStruct(&(*goSlice)[i], unsafe.Pointer(cIdx))
	}
}
func {{$Md.Name}}__Sequence_to_C(cSlice *C{{$Md.Name}}__Sequence, goSlice []{{$Md.Name}}) {
	if len(goSlice) == 0 {
		return
	}
	cSlice.data = (*C.{{$Md.Package}}__{{$Md.Type}}__{{$Md.Name}})(C.malloc((C.size_t)(C.sizeof_struct_{{$Md.Package}}__{{$Md.Type}}__{{$Md.Name}} * uintptr(len(goSlice)))))
	cSlice.capacity = C.size_t(len(goSlice))
	cSlice.size = cSlice.capacity

	for i, v := range goSlice {
		cIdx := (*C.{{$Md.Package}}__{{$Md.Type}}__{{$Md.Name}})(unsafe.Pointer(
			uintptr(unsafe.Pointer(cSlice.data)) + (C.sizeof_struct_{{$Md.Package}}__{{$Md.Type}}__{{$Md.Name}} * uintptr(i)),
		))
		{{$Md.Name}}TypeSupport.AsCStruct(unsafe.Pointer(cIdx), &v)
	}
}
func {{$Md.Name}}__Array_to_Go(goSlice []{{$Md.Name}}, cSlice []C{{$Md.Name}}) {
	for i := 0; i < len(cSlice); i++ {
		{{$Md.Name}}TypeSupport.AsGoStruct(&goSlice[i], unsafe.Pointer(&cSlice[i]))
	}
}
func {{$Md.Name}}__Array_to_C(cSlice []C{{$Md.Name}}, goSlice []{{$Md.Name}}) {
	for i := 0; i < len(goSlice); i++ {
		{{$Md.Name}}TypeSupport.AsCStruct(unsafe.Pointer(&cSlice[i]), &goSlice[i])
	}
}
`))

var ros2ServiceToGolangTypeTemplate = template.Must(template.New("ros2ServiceToGolangTypeTemplate").Funcs(templateFuncMap).Parse(
	`/*
This file is part of rclgo

Copyright © 2021 Technology Innovation Institute, United Arab Emirates

Licensed under the Apache License, Version 2.0 (the "License");
	http://www.apache.org/licenses/LICENSE-2.0
*/

/*
THIS FILE IS AUTOGENERATED BY 'rclgo-gen generate'
*/

package {{ .Service.GoPackage }}

/*
#cgo LDFLAGS: -L/opt/ros/galactic/lib -Wl,-rpath=/opt/ros/galactic/lib -lrcl -lrosidl_runtime_c -lrosidl_typesupport_c -lrcutils -lrmw_implementation
#cgo LDFLAGS: -l{{.Service.Package}}__rosidl_typesupport_c -l{{.Service.Package}}__rosidl_generator_c
#cgo CFLAGS: -I/opt/ros/galactic/include

#include <rosidl_runtime_c/message_type_support_struct.h>
#include <{{.Service.Package}}/srv/{{.Service.Name | camelToSnake}}.h>
*/
import "C"

import (
	"{{.Config.RclgoImportPath}}/pkg/rclgo/typemap"
	"{{.Config.RclgoImportPath}}/pkg/rclgo/types"

	"unsafe"
)

func init() {
	typemap.RegisterService("{{.Service.Package}}/{{.Service.Name}}", {{ .Service.Name }}TypeSupport)
}

type _{{.Service.Name}}TypeSupport struct {}

func (s _{{.Service.Name}}TypeSupport) Request() types.MessageTypeSupport {
	return {{.Service.Request.Name}}TypeSupport
}

func (s _{{.Service.Name}}TypeSupport) Response() types.MessageTypeSupport {
	return {{.Service.Response.Name}}TypeSupport
}

func (s _{{.Service.Name}}TypeSupport) TypeSupport() unsafe.Pointer {
	return unsafe.Pointer(C.rosidl_typesupport_c__get_service_type_support_handle__{{.Service.Package}}__{{.Service.Type}}__{{.Service.Name}}())
}

// Modifying this variable is undefined behavior.
var {{ .Service.Name }}TypeSupport types.ServiceTypeSupport = _{{.Service.Name}}TypeSupport{}
`))

var primitiveTypes = template.Must(template.New("primitiveTypes").Funcs(templateFuncMap).Parse(
	`/*
This file is part of rclgo

Copyright © 2021 Technology Innovation Institute, United Arab Emirates

Licensed under the Apache License, Version 2.0 (the "License");
	http://www.apache.org/licenses/LICENSE-2.0
*/

/*
THIS FILE IS AUTOGENERATED BY 'rclgo-gen generate'
*/

package primitives

/*
#cgo LDFLAGS: -L/opt/ros/galactic/lib -Wl,-rpath=/opt/ros/galactic/lib -lrcl -lrosidl_runtime_c -lrosidl_typesupport_c -lrcutils -lrmw_implementation
#cgo CFLAGS: -I/opt/ros/galactic/include

#include "rosidl_runtime_c/string.h"
#include "rosidl_runtime_c/primitives_sequence.h"

*/
import "C"
import (
	"unsafe"
){{range $k, $v := .PMap -}}{{if .SkipAutogen}}{{- else -}}
{{""}}
{{""}}
// {{.RosType | ucFirst}}
type C{{.RosType | ucFirst}} = C.{{.CType}}
type C{{.RosType | ucFirst}}__Sequence = C.rosidl_runtime_c__{{.CStructName}}__Sequence

func {{.RosType | ucFirst}}__Sequence_to_Go(goSlice *[]{{.GoType}}, cSlice C{{.RosType | ucFirst}}__Sequence) {
	if cSlice.size == 0 {
		return
	}
	*goSlice = make([]{{.GoType}}, int64(cSlice.size))
	for i := 0; i < int(cSlice.size); i++ {
		cIdx := (*C.{{.CType}})(unsafe.Pointer(
			uintptr(unsafe.Pointer(cSlice.data)) + (C.sizeof_{{.CType}} * uintptr(i)),
		))
		(*goSlice)[i] = {{.GoType}}(*cIdx)
	}
}
func {{.RosType | ucFirst}}__Sequence_to_C(cSlice *C{{.RosType | ucFirst}}__Sequence, goSlice []{{.GoType}}) {
	if len(goSlice) == 0 {
		return
	}
	cSlice.data = (*C.{{.CType}})(C.malloc((C.size_t)(C.sizeof_{{.CType}} * uintptr(len(goSlice)))))
	cSlice.capacity = C.size_t(len(goSlice))
	cSlice.size = cSlice.capacity

	for i, v := range goSlice {
		cIdx := (*C.{{.CType}})(unsafe.Pointer(
			uintptr(unsafe.Pointer(cSlice.data)) + (C.sizeof_{{.CType}} * uintptr(i)),
		))
		*cIdx = (C.{{.CType}})(v)
	}
}
func {{.RosType | ucFirst}}__Array_to_Go(goSlice []{{.GoType}}, cSlice []C{{.RosType | ucFirst}}) {
	for i := 0; i < len(cSlice); i++ {
		goSlice[i] = {{.GoType}}(cSlice[i])
	}
}
func {{.RosType | ucFirst}}__Array_to_C(cSlice []C{{.RosType | ucFirst}}, goSlice []{{.GoType}}) {
	for i := 0; i < len(goSlice); i++ {
		cSlice[i] = C.{{.CType}}(goSlice[i])
	}
}
{{- end}}{{- end}}
`))

var ros2MsgImportAllPackage = template.Must(template.New("ros2MsgToGolangTypeTemplate").Funcs(templateFuncMap).Parse(
	`/*
This file is part of rclgo

Copyright © 2021 Technology Innovation Institute, United Arab Emirates

Licensed under the Apache License, Version 2.0 (the "License");
	http://www.apache.org/licenses/LICENSE-2.0
*/

/*
THIS FILE IS AUTOGENERATED BY 'rclgo-gen generate'
*/

package msgs

import (
	{{- range $import, $unused := .Packages }}
	_ "{{$.Config.MessageModulePrefix}}/{{$import}}" //
	{{- end }}
)
`))

var ros2ErrorCodes = template.Must(template.New("ros2ErrorCodes").Funcs(templateFuncMap).Parse(
	`/*{{ $P := . }}
This file is part of rclgo

Copyright © 2021 Technology Innovation Institute, United Arab Emirates

Licensed under the Apache License, Version 2.0 (the "License");
	http://www.apache.org/licenses/LICENSE-2.0
*/

/*
THIS FILE IS AUTOGENERATED BY 'rclgo-gen generate'
*/

package rclgo

/*
#cgo LDFLAGS: -L/opt/ros/galactic/lib -Wl,-rpath=/opt/ros/galactic/lib -lrcl -lrosidl_runtime_c -lrosidl_typesupport_c -lrcutils -lrmw_implementation

#include <rcl/types.h>
#include <rmw/ret_types.h>

*/
import "C"
import (
	"runtime"
)

func errorsCastC(rcl_ret_t C.rcl_ret_t, context string) error {
	stackTraceBuffer := make([]byte, 2048)
	runtime.Stack(stackTraceBuffer, false) // Get stack trace of the current running thread only

	// https://stackoverflow.com/questions/9928221/table-of-functions-vs-switch-in-golang
	// switch-case is faster thanks to compiler optimization than a dispatcher?
	switch rcl_ret_t {
	{{range $e := .ERRORS -}}{{if $e.Rcl_ret_t -}}{{if not (index $P.DEDUP_FILTER $e.Name) -}}
	case C.{{$e.Name}}:
		return &{{$e.Name|cReturnCodeNameToGo}}{rclRetStruct: rclRetStruct{rclRetCode: {{$e.Rcl_ret_t}}, trace: string(stackTraceBuffer), context: errorsBuildContext(&{{$e.Name|cReturnCodeNameToGo}}{}, context, string(stackTraceBuffer))}}
	{{""}}
	{{- end}}{{- end}}{{- end}}
	default:
		return &UnknownReturnCode{rclRetStruct: rclRetStruct{rclRetCode: int(rcl_ret_t), context: context}}
	}
}

type UnknownReturnCode struct {
	rclRetStruct
}

{{range $e := .ERRORS -}}{{if $e.Rcl_ret_t}}
// {{$e.Name|cReturnCodeNameToGo}} {{$e.Comment}}
type {{$e.Name|cReturnCodeNameToGo}} struct {
	rclRetStruct
}
{{""}}
{{- end}}{{- end}}

{{range $e := .ERRORS -}}{{if $e.Reference}}
// {{$e.Name|cReturnCodeNameToGo}} {{$e.Comment}}
type {{$e.Name|cReturnCodeNameToGo}} = {{$e.Reference|cReturnCodeNameToGo}}
{{""}}
{{- end}}{{- end}}

`))
